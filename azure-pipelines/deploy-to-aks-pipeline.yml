trigger: none # Manual trigger only

# Uncomment and configure after creating the build pipeline
# resources:
#   pipelines:
#     - pipeline: buildPipeline
#       source: 'Build and Push Images'  # Must match exact pipeline name in Azure DevOps
#       trigger:
#         branches:
#           include:
#             - main

parameters:
  - name: environment
    displayName: "Environment"
    type: string
    default: "dev"
    values:
      - dev
      - staging
      - prod
  - name: imageTag
    displayName: "Image Tag"
    type: string
    default: "latest"

variables:
  - name: azureServiceConnection
    value: "azure-ecommerce-sp"
  - name: resourceGroupPrefix
    value: "rg-ecommerce-aks"
  - name: resourceGroup
    value: "$(resourceGroupPrefix)-${{ parameters.environment }}"
  - name: namespace
    value: "ecommerce"

stages:
  - stage: PreDeploy
    displayName: "Pre-Deployment Checks"
    jobs:
      - job: ValidateCluster
        displayName: "Validate AKS Cluster"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - task: AzureCLI@2
            displayName: "Check Cluster Status"
            name: CheckCluster
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                # Get AKS cluster name
                AKS_NAME=$(az aks list \
                  --resource-group $(resourceGroup) \
                  --query "[0].name" \
                  --output tsv)

                if [ -z "$AKS_NAME" ]; then
                  echo "##vso[task.logissue type=error]AKS cluster not found in $(resourceGroup)"
                  echo "Please run the Infrastructure pipeline first"
                  exit 1
                fi

                echo "##vso[task.setvariable variable=aksClusterName;isOutput=true]$AKS_NAME"

                # Get cluster status
                PROVISIONING_STATE=$(az aks show \
                  --resource-group $(resourceGroup) \
                  --name $AKS_NAME \
                  --query 'provisioningState' \
                  --output tsv)

                echo "AKS Cluster: $AKS_NAME"
                echo "Status: $PROVISIONING_STATE"

                if [ "$PROVISIONING_STATE" != "Succeeded" ]; then
                  echo "##vso[task.logissue type=error]Cluster is not in Succeeded state"
                  exit 1
                fi

                echo "✅ Cluster validation passed"

  - stage: DeployDataLayer
    displayName: "Deploy Data Layer"
    dependsOn: PreDeploy
    jobs:
      - deployment: DeployData
        displayName: "Deploy PostgreSQL, Redis, RabbitMQ"
        environment: ${{ parameters.environment }}
        pool:
          vmImage: "ubuntu-latest"
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: AzureCLI@2
                  displayName: "Get AKS Credentials"
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      AKS_NAME=$(az aks list \
                        --resource-group $(resourceGroup) \
                        --query "[0].name" \
                        --output tsv)

                      ACR_NAME=$(az acr list \
                        --resource-group $(resourceGroup) \
                        --query "[0].name" \
                        --output tsv)

                      echo "##vso[task.setvariable variable=aksClusterName]$AKS_NAME"
                      echo "##vso[task.setvariable variable=acrName]$ACR_NAME"

                      # Get AKS credentials with admin access
                      az aks get-credentials \
                        --resource-group $(resourceGroup) \
                        --name $AKS_NAME \
                        --overwrite-existing \
                        --admin

                - bash: |
                    kubectl apply -f kubernetes/base/namespace.yaml
                  displayName: "Create Namespace"

                - bash: |
                    # Create secrets (use variables from pipeline library)
                    kubectl create secret generic database-secrets \
                      --from-literal=POSTGRES_USER=postgres \
                      --from-literal=POSTGRES_PASSWORD=$(POSTGRES_PASSWORD) \
                      --from-literal=POSTGRES_HOST=postgres-service \
                      --from-literal=POSTGRES_PORT=5432 \
                      --from-literal=PRODUCT_DB_NAME=products_db \
                      --from-literal=PRODUCT_DB_USER=postgres \
                      --from-literal=PRODUCT_DB_PASSWORD=$(POSTGRES_PASSWORD) \
                      --from-literal=USER_DB_NAME=users_db \
                      --from-literal=USER_DB_USER=postgres \
                      --from-literal=USER_DB_PASSWORD=$(POSTGRES_PASSWORD) \
                      --from-literal=REDIS_HOST=redis-service \
                      --from-literal=REDIS_PORT=6379 \
                      --from-literal=RABBITMQ_HOST=rabbitmq-service \
                      --from-literal=RABBITMQ_PORT=5672 \
                      --from-literal=RABBITMQ_USER=admin \
                      --from-literal=RABBITMQ_PASSWORD=$(RABBITMQ_PASSWORD) \
                      -n $(namespace) \
                      --dry-run=client -o yaml | kubectl apply -f -

                    # Create JWT secrets
                    kubectl create secret generic jwt-secrets \
                      --from-literal=JWT_SECRET=$(JWT_SECRET) \
                      --from-literal=JWT_ALGORITHM=HS256 \
                      -n $(namespace) \
                      --dry-run=client -o yaml | kubectl apply -f -

                    echo "✅ Secrets created"
                  displayName: "Create Secrets"
                  env:
                    POSTGRES_PASSWORD: $(POSTGRES_PASSWORD)
                    RABBITMQ_PASSWORD: $(RABBITMQ_PASSWORD)
                    JWT_SECRET: $(JWT_SECRET)

                - bash: |
                    kubectl apply -f kubernetes/data-layer/postgres/
                  displayName: "Deploy PostgreSQL"

                - bash: |
                    kubectl apply -f kubernetes/data-layer/redis/
                  displayName: "Deploy Redis"

                - bash: |
                    kubectl apply -f kubernetes/data-layer/rabbitmq/
                  displayName: "Deploy RabbitMQ"

                - bash: |
                    echo "Waiting for data layer pods to be ready..."
                    kubectl wait --for=condition=ready pod -l app=postgres -n $(namespace) --timeout=300s || true
                    kubectl wait --for=condition=ready pod -l app=redis -n $(namespace) --timeout=120s || true
                    kubectl wait --for=condition=ready pod -l app=rabbitmq -n $(namespace) --timeout=300s || true

                    echo "Data layer status:"
                    kubectl get pods -n $(namespace) -l 'app in (postgres,redis,rabbitmq)'
                  displayName: "Wait for Data Layer"

  - stage: DeployServices
    displayName: "Deploy Microservices"
    dependsOn: DeployDataLayer
    jobs:
      - deployment: DeployApps
        displayName: "Deploy Applications"
        environment: ${{ parameters.environment }}
        pool:
          vmImage: "ubuntu-latest"
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: AzureCLI@2
                  displayName: "Get Cluster Info"
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      AKS_NAME=$(az aks list \
                        --resource-group $(resourceGroup) \
                        --query "[0].name" \
                        --output tsv)

                      ACR_NAME=$(az acr list \
                        --resource-group $(resourceGroup) \
                        --query "[0].name" \
                        --output tsv)

                      echo "##vso[task.setvariable variable=aksClusterName]$AKS_NAME"
                      echo "##vso[task.setvariable variable=acrName]$ACR_NAME"

                      az aks get-credentials \
                        --resource-group $(resourceGroup) \
                        --name $AKS_NAME \
                        --overwrite-existing \
                        --admin

                - bash: |
                    # Get ACR info
                    ACR_NAME=$(az acr list \
                      --resource-group $(resourceGroup) \
                      --query "[0].name" \
                      --output tsv)

                    ACR_LOGIN_SERVER="${ACR_NAME}.azurecr.io"

                    echo "Updating manifests with ACR: $ACR_NAME"
                    echo "Login Server: $ACR_LOGIN_SERVER"
                    echo ""

                    # Update image references in ALL deployment files
                    # Replace <YOUR_ACR> and <YOUR_REGISTRY> with actual ACR name
                    find kubernetes/services -name "deployment.yaml" -type f | while read file; do
                      echo "Updating: $file"
                      
                      # Replace <YOUR_ACR>
                      sed -i "s|<YOUR_ACR>|${ACR_NAME}|g" "$file"
                      
                      # Replace <YOUR_REGISTRY>
                      sed -i "s|<YOUR_REGISTRY>|${ACR_NAME}|g" "$file"
                      
                      # Ensure .azurecr.io is added if not present
                      sed -i "s|image: ${ACR_NAME}/|image: ${ACR_LOGIN_SERVER}/|g" "$file"
                      
                      # Update image tags
                      sed -i "s|:latest|:${{ parameters.imageTag }}|g" "$file"
                      
                      echo "Updated image references in $file"
                    done

                    echo ""
                    echo "Verifying updates..."
                    echo "─────────────────────────────────────────"
                    grep "image:" kubernetes/services/*/deployment.yaml
                    echo "─────────────────────────────────────────"
                    echo ""
                    echo "✅ Manifests updated"
                  displayName: "Update Manifests"

                - bash: |
                    kubectl apply -f kubernetes/services/product-service/
                  displayName: "Deploy Product Service"

                - bash: |
                    kubectl apply -f kubernetes/services/user-service/
                  displayName: "Deploy User Service"

                - bash: |
                    kubectl apply -f kubernetes/services/frontend-service/
                  displayName: "Deploy Frontend Service"

                - bash: |
                    echo "Waiting for service pods to be ready..."
                    kubectl wait --for=condition=ready pod -l app=product-service -n $(namespace) --timeout=300s || true
                    kubectl wait --for=condition=ready pod -l app=user-service -n $(namespace) --timeout=300s || true
                    kubectl wait --for=condition=ready pod -l app=frontend-service -n $(namespace) --timeout=300s || true

                    echo "Service status:"
                    kubectl get pods -n $(namespace) -l 'app in (product-service,user-service,frontend-service)'
                  displayName: "Wait for Services"

  - stage: ConfigureIngress
    displayName: "Configure Ingress"
    dependsOn: DeployServices
    jobs:
      - deployment: DeployIngress
        displayName: "Deploy Ingress Controller"
        environment: ${{ parameters.environment }}
        pool:
          vmImage: "ubuntu-latest"
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: AzureCLI@2
                  displayName: "Get Credentials"
                  inputs:
                    azureSubscription: $(azureServiceConnection)
                    scriptType: "bash"
                    scriptLocation: "inlineScript"
                    inlineScript: |
                      AKS_NAME=$(az aks list \
                        --resource-group $(resourceGroup) \
                        --query "[0].name" \
                        --output tsv)

                      echo "##vso[task.setvariable variable=aksClusterName]$AKS_NAME"

                      az aks get-credentials \
                        --resource-group $(resourceGroup) \
                        --name $AKS_NAME \
                        --overwrite-existing \
                        --admin

                - bash: |
                    kubectl apply -f kubernetes/ingress/
                  displayName: "Deploy Ingress"

                - bash: |
                    echo "Waiting for ingress IP..."
                    for i in {1..30}; do
                      INGRESS_IP=$(kubectl get ingress ecommerce-ingress -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
                      if [ -n "$INGRESS_IP" ]; then
                        echo "##vso[task.setvariable variable=ingressIP]$INGRESS_IP"
                        echo "Ingress IP: $INGRESS_IP"
                        break
                      fi
                      echo "Waiting for ingress IP... ($i/30)"
                      sleep 10
                    done
                  displayName: "Get Ingress IP"

  - stage: HealthCheck
    displayName: "Health Checks"
    dependsOn: ConfigureIngress
    jobs:
      - job: RunHealthChecks
        displayName: "Verify Deployment"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - task: AzureCLI@2
            displayName: "Get Credentials"
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                AKS_NAME=$(az aks list \
                  --resource-group $(resourceGroup) \
                  --query "[0].name" \
                  --output tsv)

                az aks get-credentials \
                  --resource-group $(resourceGroup) \
                  --name $AKS_NAME \
                  --overwrite-existing \
                  --admin

          - bash: |
              echo "=== Deployment Status ==="
              kubectl get all -n $(namespace)

              echo ""
              echo "=== Pod Status ==="
              kubectl get pods -n $(namespace) -o wide

              echo ""
              echo "=== Service Status ==="
              kubectl get svc -n $(namespace)

              echo ""
              echo "=== Ingress Status ==="
              kubectl get ingress -n $(namespace)
            displayName: "Show Deployment Status"

          - bash: |
              INGRESS_IP=$(kubectl get ingress ecommerce-ingress -n $(namespace) -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")

              if [ -n "$INGRESS_IP" ]; then
                echo "Testing endpoints at $INGRESS_IP..."
                
                echo "Product Service Health:"
                curl -f http://$INGRESS_IP/api/products/health || echo "Product service not ready"
                
                echo ""
                echo "User Service Health:"
                curl -f http://$INGRESS_IP/api/users/health || echo "User service not ready"
                
                echo ""
                echo "========================================="
                echo "✅ Application URL: http://$INGRESS_IP"
                echo "========================================="
              else
                echo "⚠️ Ingress IP not available yet"
                echo "Check status: kubectl get ingress -n $(namespace)"
              fi
            displayName: "Health Check Endpoints"
            continueOnError: true
